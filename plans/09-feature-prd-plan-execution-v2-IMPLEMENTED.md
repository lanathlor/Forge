# Feature: Plan Execution System v2

## What is this feature?

A hierarchical, database-first planning system where complex work is broken down into Plans → Phases → Tasks. Plans can be created through UI, API, or generated by Claude, then iterated and executed with flexible control over execution flow and manual review points.

## User Problem

**Without this feature**:
- No structured way to plan and track complex multi-step work
- Can't break down large features into manageable chunks
- No visibility into progress across multiple phases of work
- Can't pause execution for review and manual intervention
- No way to collaborate with Claude on improving plans

**With this feature**:
- Create detailed plans with phases and tasks
- Claude can help generate, refine, and optimize plans
- Execute plans with control: step-by-step, parallel, or mixed
- Pause at any point for manual review
- Track progress granularly (task → phase → plan level)
- Resume failed or paused plans from where they left off
- Iterate on plans before execution

## Core Concepts

### Hierarchy

```
Plan
├── Phase 1
│   ├── Task 1.1
│   ├── Task 1.2 (can run parallel with 1.1)
│   └── Task 1.3 (depends on 1.1, 1.2)
├── Phase 2 (starts after Phase 1 completes)
│   ├── Task 2.1
│   └── Task 2.2
└── Phase 3
    └── Task 3.1
```

### Plan
- Top-level container for a body of work
- Has title, description, and multiple phases
- Can be in states: `draft` → `ready` → `running` → `paused` → `completed`/`failed`
- Created via UI, API, or Claude generation

### Phase
- Logical grouping of related tasks
- Executes in order (Phase 2 starts after Phase 1 completes)
- Has execution mode:
  - **sequential**: tasks run one-by-one
  - **parallel**: tasks run simultaneously (respecting dependencies)
  - **manual**: requires user approval between each task
- Can be configured to pause after completion for review

### Task
- Atomic unit of work
- Has clear description of what Claude should do
- Can have dependencies on other tasks
- Can be marked as parallelizable
- Executes with Claude, runs QA gates, auto-commits on success
- Retries on failure (up to 3 attempts)

## User Stories

### Story 1: Generate Plan with Claude
```
AS A developer
I WANT to describe a feature and have Claude generate a detailed plan
SO THAT I don't have to manually break down complex work
```

### Story 2: Iterative Refinement
```
AS A developer
I WANT Claude to review and improve my plan
SO THAT I can catch missing tasks and improve descriptions before execution
```

### Story 3: Flexible Execution Control
```
AS A developer
I WANT to run tasks in parallel where possible, and pause for review between phases
SO THAT I can move fast but still maintain control
```

### Story 4: Resume from Failure
```
AS A developer
I WANT to fix issues manually and resume plan execution
SO THAT I don't have to restart the entire plan when one task fails
```

### Story 5: Manual Editing
```
AS A developer
I WANT to edit task descriptions and reorder phases
SO THAT I can adapt the plan based on what I learn
```

## User Flows

### Flow 1: Generate Plan from Description

```
1. User opens dashboard, clicks "New Plan"
   ↓
2. User enters:
   - Title: "Add user authentication"
   - Description: "Add JWT-based auth with login/logout/protected routes"
   ↓
3. User clicks "Generate Plan with Claude"
   ↓
4. Claude analyzes and generates:

   Plan: Add user authentication

   Phase 1: Database & Models
   - Create User model with email, passwordHash
   - Add database migration
   - Add password hashing utilities

   Phase 2: Auth Logic
   - Create JWT generation/verification utilities
   - Create auth middleware
   - Add login endpoint
   - Add logout endpoint

   Phase 3: Integration
   - Protect existing API routes
   - Add auth state to frontend
   - Add login/logout UI

   ↓
5. Plan saved as "draft" status
   ↓
6. User reviews plan in UI:
   - See all phases and tasks
   - Can edit descriptions
   - Can add/remove/reorder tasks
   - Can mark phases to pause after completion
   ↓
7. User clicks "Ask Claude to Review"
   ↓
8. Claude analyzes and suggests:
   - "Phase 2, Task 2 should come before Task 1 (need utilities before middleware)"
   - "Missing task: Add refresh token support"
   - "Task description improved: 'Create auth middleware' → 'Create auth middleware that verifies JWT and adds user to request context'"
   ↓
9. User accepts suggestions, plan updated
   ↓
10. User marks plan as "ready"
```

### Flow 2: Execute Plan with Pause Points

```
1. User opens plan in "ready" status
   ↓
2. User configures execution:
   - Phase 1: sequential, pause after
   - Phase 2: parallel (where possible), pause after
   - Phase 3: manual approval per task
   ↓
3. User clicks "Start Execution"
   ↓
4. Phase 1 begins:
   - Task 1.1: Create User model (running)
   - Task 1.2: pending
   - Task 1.3: pending
   ↓
5. Task 1.1 completes → QA passes → commits
   ↓
6. Task 1.2 begins → completes → commits
   ↓
7. Task 1.3 begins → QA fails → retry (attempt 2)
   ↓
8. Task 1.3 retry → QA passes → commits
   ↓
9. Phase 1 complete → PAUSE (configured to pause after)

   UI shows:
   ┌─────────────────────────────────────────┐
   │ ⏸️  Plan Paused for Review               │
   ├─────────────────────────────────────────┤
   │ Phase 1: Database & Models ✅           │
   │ 3/3 tasks completed                     │
   │                                         │
   │ Changes:                                │
   │ • Created src/models/User.ts            │
   │ • Added migration 001_users.sql         │
   │ • Created src/lib/password.ts           │
   │ • 3 commits                             │
   │                                         │
   │ Next: Phase 2: Auth Logic (3 tasks)    │
   │                                         │
   │ [Review Changes] [Continue] [Stop]      │
   └─────────────────────────────────────────┘

   ↓
10. User reviews changes, clicks "Continue"
    ↓
11. Phase 2 begins (parallel mode):
    - Task 2.1: Create JWT utilities (running)
    - Task 2.2: Create auth middleware (running) [in parallel]
    - Task 2.3: waiting for 2.1, 2.2
    ↓
12. Task 2.1 completes → commits
    ↓
13. Task 2.2 completes → commits
    ↓
14. Task 2.3 begins → completes → commits
    ↓
15. Phase 2 complete → PAUSE
    ↓
16. User continues → Phase 3 begins (manual mode)
    ↓
17. Task 3.1 ready:

    UI shows:
    ┌─────────────────────────────────────────┐
    │ Task 3.1: Protect existing API routes   │
    ├─────────────────────────────────────────┤
    │ Add auth middleware to:                 │
    │ - POST /api/tasks                       │
    │ - DELETE /api/tasks/:id                 │
    │ - PUT /api/repositories/:id             │
    │                                         │
    │ [Execute Task] [Skip] [Edit]            │
    └─────────────────────────────────────────┘

    ↓
18. User clicks "Execute Task"
    ↓
19. Task runs → completes → commits
    ↓
20. All phases complete:

    ┌─────────────────────────────────────────┐
    │ ✅ Plan Completed                       │
    ├─────────────────────────────────────────┤
    │ Add user authentication                 │
    │                                         │
    │ 3 phases, 9 tasks completed             │
    │ Duration: 1h 23m                        │
    │ Commits: 9                              │
    │                                         │
    │ [View Changes] [Create New Plan]        │
    └─────────────────────────────────────────┘
```

### Flow 3: Handle Failure and Manual Fix

```
1. Plan executing, task fails after 3 retries
   ↓
2. Plan automatically pauses:

   ┌─────────────────────────────────────────┐
   │ ⚠️  Task Failed - Manual Fix Required   │
   ├─────────────────────────────────────────┤
   │ Phase 2, Task 2: Create auth middleware │
   │                                         │
   │ Failed after 3 attempts                 │
   │                                         │
   │ Last QA failure:                        │
   │ TypeScript: Property 'user' does not    │
   │ exist on type 'Request'                 │
   │                                         │
   │ Options:                                │
   │ • Fix manually and mark task complete   │
   │ • Edit task description and retry       │
   │ • Skip this task                        │
   │ • Cancel plan                           │
   │                                         │
   │ [Fix Manually] [Edit & Retry] [Skip]    │
   └─────────────────────────────────────────┘

   ↓
3. User clicks "Fix Manually"
   ↓
4. User edits code directly, fixes TypeScript error
   ↓
5. User runs QA gates manually (or they run automatically)
   ↓
6. QA passes
   ↓
7. User marks task as complete
   ↓
8. Plan resumes from next task
```

## Database Schema

### plans table
```typescript
{
  id: string (uuid)
  repositoryId: string (fk)
  title: string
  description: string?
  status: enum ('draft', 'ready', 'running', 'paused', 'completed', 'failed')

  // Metadata
  createdBy: enum ('user', 'claude', 'api')
  sourceFile: string?  // if imported from markdown

  // Execution state
  currentPhaseId: string?
  currentTaskId: string?
  startingCommit: string?

  // Stats
  totalPhases: integer
  completedPhases: integer
  totalTasks: integer
  completedTasks: integer

  createdAt: timestamp
  updatedAt: timestamp
  startedAt: timestamp?
  completedAt: timestamp?
}
```

### phases table
```typescript
{
  id: string (uuid)
  planId: string (fk)
  order: integer  // 1, 2, 3...
  title: string
  description: string?
  status: enum ('pending', 'running', 'completed', 'failed', 'paused')

  // Execution configuration
  executionMode: enum ('sequential', 'parallel', 'manual')
  pauseAfter: boolean  // pause plan after this phase completes?

  // Stats
  totalTasks: integer
  completedTasks: integer
  failedTasks: integer

  startedAt: timestamp?
  completedAt: timestamp?
  createdAt: timestamp
  updatedAt: timestamp
}
```

### tasks table
```typescript
{
  id: string (uuid)
  phaseId: string (fk)
  planId: string (fk)  // denormalized for easier queries
  order: integer  // 1, 2, 3... within phase
  title: string
  description: string  // detailed instructions for Claude
  status: enum ('pending', 'running', 'completed', 'failed', 'skipped')

  // Dependencies & parallelization
  dependsOn: string[]  // task IDs that must complete first
  canRunInParallel: boolean

  // Execution tracking
  attempts: integer (default: 0, max: 3)
  lastError: string?
  lastQaResults: json?

  // Results
  sessionId: string?  // Claude session that executed this
  commitSha: string?

  startedAt: timestamp?
  completedAt: timestamp?
  createdAt: timestamp
  updatedAt: timestamp
}
```

### plan_iterations table (for Claude review history)
```typescript
{
  id: string (uuid)
  planId: string (fk)
  iterationType: enum ('generation', 'review', 'refine', 'user_edit')
  prompt: string?  // what was asked
  changes: json  // what changed (added/removed/modified tasks/phases)
  changedBy: enum ('user', 'claude')
  createdAt: timestamp
}
```

## API Endpoints

### Plans

**POST /api/plans/generate**
```typescript
Request:
{
  repositoryId: string,
  title: string,
  description: string,  // feature description
  generateWith: 'claude'
}

Response:
{
  planId: string,
  status: 'draft',
  phases: Phase[],
  tasks: Task[]
}
```

**POST /api/plans/create**
```typescript
Request:
{
  repositoryId: string,
  title: string,
  description?: string,
  phases: {
    title: string,
    description?: string,
    executionMode: 'sequential' | 'parallel' | 'manual',
    pauseAfter: boolean,
    tasks: {
      title: string,
      description: string,
      dependsOn?: string[],
      canRunInParallel?: boolean
    }[]
  }[]
}

Response: Plan
```

**GET /api/plans?repositoryId=xxx**
```typescript
Response:
{
  plans: Plan[]
}
```

**GET /api/plans/:id**
```typescript
Response:
{
  plan: Plan,
  phases: Phase[],
  tasks: Task[],
  iterations: PlanIteration[]
}
```

**PATCH /api/plans/:id**
```typescript
Request:
{
  title?: string,
  description?: string,
  status?: 'draft' | 'ready'
}

Response: Plan
```

**DELETE /api/plans/:id**

### Plan Review/Iteration

**POST /api/plans/:id/review**
```typescript
Request:
{
  reviewType: 'refine_descriptions' | 'add_missing' | 'optimize_order' | 'break_down',
  scope?: 'all' | 'phase' | 'task',
  targetId?: string  // phase/task ID if scope is specific
}

Response:
{
  suggestions: {
    type: 'add_task' | 'modify_task' | 'reorder' | 'add_phase',
    target: string,  // what to change
    reasoning: string,
    before?: any,
    after?: any
  }[],
  iterationId: string
}
```

**POST /api/plans/:id/apply-suggestions**
```typescript
Request:
{
  iterationId: string,
  suggestionIds: string[]  // which suggestions to apply
}

Response: Plan (updated)
```

### Plan Execution

**POST /api/plans/:id/execute**
```typescript
Request:
{
  startFrom?: 'beginning' | 'current' | 'phase' | 'task',
  targetId?: string  // if startFrom is 'phase' or 'task'
}

Response:
{
  executionId: string,
  status: 'running'
}
```

**POST /api/plans/:id/pause**
```typescript
Response:
{
  status: 'paused',
  currentPhaseId: string,
  currentTaskId: string
}
```

**POST /api/plans/:id/resume**
```typescript
Response:
{
  status: 'running'
}
```

**POST /api/plans/:id/cancel**
```typescript
Response:
{
  status: 'failed',
  reason: 'cancelled_by_user'
}
```

### Phases

**POST /api/phases**
```typescript
Request:
{
  planId: string,
  title: string,
  description?: string,
  order: integer,
  executionMode: 'sequential' | 'parallel' | 'manual',
  pauseAfter: boolean
}

Response: Phase
```

**PATCH /api/phases/:id**
```typescript
Request:
{
  title?: string,
  description?: string,
  order?: integer,
  executionMode?: 'sequential' | 'parallel' | 'manual',
  pauseAfter?: boolean
}

Response: Phase
```

**DELETE /api/phases/:id**

### Tasks

**POST /api/tasks**
```typescript
Request:
{
  phaseId: string,
  title: string,
  description: string,
  order: integer,
  dependsOn?: string[],
  canRunInParallel?: boolean
}

Response: Task
```

**PATCH /api/tasks/:id**
```typescript
Request:
{
  title?: string,
  description?: string,
  order?: integer,
  status?: 'pending' | 'skipped' | 'completed',  // manual status updates
  dependsOn?: string[],
  canRunInParallel?: boolean
}

Response: Task
```

**DELETE /api/tasks/:id**

**POST /api/tasks/:id/retry**
```typescript
// Retry a failed task
Response: Task (status: 'running')
```

## Execution Engine

### Core Logic

```typescript
// src/lib/plans/executor.ts

export class PlanExecutor {
  async executePlan(planId: string): Promise<void> {
    const plan = await loadPlanWithPhases(planId);

    // Update plan status
    await db.update(plans)
      .set({ status: 'running', startedAt: new Date() })
      .where(eq(plans.id, planId));

    // Execute phases in order
    for (const phase of plan.phases) {
      await this.executePhase(planId, phase.id);

      // Check if should pause after this phase
      if (phase.pauseAfter) {
        await this.pausePlan(planId, 'phase_complete');
        return; // Wait for user to resume
      }
    }

    // All phases complete
    await db.update(plans)
      .set({
        status: 'completed',
        completedAt: new Date()
      })
      .where(eq(plans.id, planId));
  }

  async executePhase(planId: string, phaseId: string): Promise<void> {
    const phase = await loadPhaseWithTasks(phaseId);

    // Update phase status
    await db.update(phases)
      .set({ status: 'running', startedAt: new Date() })
      .where(eq(phases.id, phaseId));

    switch (phase.executionMode) {
      case 'sequential':
        await this.executeTasksSequentially(phase.tasks);
        break;

      case 'parallel':
        await this.executeTasksInParallel(phase.tasks);
        break;

      case 'manual':
        await this.executeTasksManually(phase.tasks);
        break;
    }

    // Mark phase complete
    await db.update(phases)
      .set({
        status: 'completed',
        completedAt: new Date()
      })
      .where(eq(phases.id, phaseId));
  }

  async executeTasksSequentially(tasks: Task[]): Promise<void> {
    for (const task of tasks) {
      await this.executeTask(task.id);
    }
  }

  async executeTasksInParallel(tasks: Task[]): Promise<void> {
    // Build dependency graph
    const graph = buildDependencyGraph(tasks);
    const completed = new Set<string>();

    while (completed.size < tasks.length) {
      // Find tasks ready to run (dependencies met, can run in parallel)
      const ready = tasks.filter(task =>
        !completed.has(task.id) &&
        task.dependsOn.every(depId => completed.has(depId)) &&
        task.canRunInParallel
      );

      if (ready.length === 0) {
        // No parallel tasks ready, run next sequential task
        const nextSequential = tasks.find(task =>
          !completed.has(task.id) &&
          task.dependsOn.every(depId => completed.has(depId))
        );

        if (nextSequential) {
          await this.executeTask(nextSequential.id);
          completed.add(nextSequential.id);
        }
      } else {
        // Run parallel tasks concurrently
        await Promise.all(
          ready.map(task =>
            this.executeTask(task.id).then(() => completed.add(task.id))
          )
        );
      }
    }
  }

  async executeTasksManually(tasks: Task[]): Promise<void> {
    for (const task of tasks) {
      // Wait for user approval before each task
      await this.pausePlan(task.planId, 'manual_approval_required', task.id);

      // When resumed, execute the task
      await this.executeTask(task.id);
    }
  }

  async executeTask(taskId: string): Promise<void> {
    const task = await db.query.tasks.findFirst({
      where: eq(tasks.id, taskId),
      with: { phase: { with: { plan: true } } }
    });

    let attempt = 0;
    const MAX_RETRIES = 3;

    while (attempt < MAX_RETRIES) {
      attempt++;

      try {
        // Update task status
        await db.update(tasks)
          .set({
            status: 'running',
            attempts: attempt,
            startedAt: attempt === 1 ? new Date() : undefined
          })
          .where(eq(tasks.id, taskId));

        // Build prompt
        let prompt = task.description;

        // Add retry context if needed
        if (attempt > 1 && task.lastError) {
          prompt = `Previous attempt failed. Error:\n${task.lastError}\n\nPlease fix and try again.\n\nOriginal task:\n${task.description}`;
        }

        // Execute with Claude (fresh session per task)
        const session = await createClaudeSession({
          repositoryPath: task.phase.plan.repository.path,
          prompt,
        });

        // Wait for completion
        await waitForSessionComplete(session.id);

        // Run QA gates
        const qaResults = await runQAGates(
          taskId,
          task.phase.plan.repository.path
        );

        const allPassed = qaResults.every(r =>
          r.status === 'passed' || r.status === 'skipped'
        );

        if (allPassed) {
          // Success! Commit changes
          const diff = await captureDiff(task.phase.plan.repository.path);
          const commitMsg = await generateCommitMessage(diff, task.title);
          const commitSha = await commitChanges(
            task.phase.plan.repository.path,
            diff.changedFiles.map(f => f.path),
            commitMsg
          );

          // Mark task complete
          await db.update(tasks)
            .set({
              status: 'completed',
              completedAt: new Date(),
              commitSha,
              sessionId: session.id,
            })
            .where(eq(tasks.id, taskId));

          return; // Success

        } else {
          // QA failed
          const errors = qaResults
            .filter(r => r.status === 'failed')
            .map(r => `${r.gateName}: ${r.errors.join('\n')}`)
            .join('\n\n');

          await db.update(tasks)
            .set({
              lastError: errors,
              lastQaResults: qaResults,
            })
            .where(eq(tasks.id, taskId));

          if (attempt >= MAX_RETRIES) {
            // Max retries reached
            await db.update(tasks)
              .set({
                status: 'failed',
                lastError: `QA failed after ${MAX_RETRIES} attempts:\n${errors}`
              })
              .where(eq(tasks.id, taskId));

            // Pause plan for manual intervention
            await this.pausePlan(task.planId, 'task_failed', taskId);
            throw new Error(`Task ${taskId} failed after ${MAX_RETRIES} attempts`);
          }

          // Will retry
        }

      } catch (error) {
        await db.update(tasks)
          .set({
            status: 'failed',
            lastError: error instanceof Error ? error.message : 'Unknown error'
          })
          .where(eq(tasks.id, taskId));

        throw error;
      }
    }
  }

  async pausePlan(
    planId: string,
    reason: string,
    contextTaskId?: string
  ): Promise<void> {
    await db.update(plans)
      .set({
        status: 'paused',
        currentTaskId: contextTaskId
      })
      .where(eq(plans.id, planId));

    // Emit event for UI
    await emitPlanEvent(planId, 'paused', { reason, taskId: contextTaskId });
  }

  async resumePlan(planId: string): Promise<void> {
    await db.update(plans)
      .set({ status: 'running' })
      .where(eq(plans.id, planId));

    // Continue execution
    await this.executePlan(planId);
  }
}
```

## Plan Generation with Claude

```typescript
// src/lib/plans/generator.ts

export async function generatePlanFromDescription(
  repositoryId: string,
  title: string,
  description: string
): Promise<string> {
  // Create draft plan
  const plan = await db.insert(plans).values({
    id: generateId(),
    repositoryId,
    title,
    description,
    status: 'draft',
    createdBy: 'claude',
    createdAt: new Date(),
    updatedAt: new Date(),
  }).returning();

  const planId = plan[0].id;

  // Get repository info
  const repo = await db.query.repositories.findFirst({
    where: eq(repositories.id, repositoryId)
  });

  // Ask Claude to generate plan structure
  const prompt = `
You are helping plan a software development task. Analyze the repository and break down the following feature into a structured plan.

Feature: ${title}
Description: ${description}

Repository: ${repo.path}

Please create a detailed implementation plan with:
1. **Phases**: Logical groups of related work (e.g., "Database Setup", "API Implementation", "UI Components")
2. **Tasks**: Specific, atomic units of work within each phase

For each phase, specify:
- Title and description
- Execution mode: sequential (one task at a time), parallel (tasks can run together), or manual (require approval per task)
- Whether to pause after this phase for review

For each task, specify:
- Title and detailed description (what I should do)
- Any dependencies on other tasks
- Whether it can run in parallel with other tasks

Return the plan as JSON in this format:
{
  "phases": [
    {
      "title": "Phase title",
      "description": "What this phase accomplishes",
      "executionMode": "sequential" | "parallel" | "manual",
      "pauseAfter": true | false,
      "tasks": [
        {
          "title": "Task title",
          "description": "Detailed instructions for what to do",
          "dependsOn": [],  // task indices in THIS phase that must complete first
          "canRunInParallel": true | false
        }
      ]
    }
  ]
}
`;

  const session = await createClaudeSession({
    repositoryPath: repo.path,
    prompt,
  });

  const response = await waitForSessionResponse(session.id);
  const planStructure = JSON.parse(response);

  // Save phases and tasks to database
  for (let phaseIdx = 0; phaseIdx < planStructure.phases.length; phaseIdx++) {
    const phaseData = planStructure.phases[phaseIdx];

    const phase = await db.insert(phases).values({
      id: generateId(),
      planId,
      order: phaseIdx + 1,
      title: phaseData.title,
      description: phaseData.description,
      executionMode: phaseData.executionMode,
      pauseAfter: phaseData.pauseAfter,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date(),
    }).returning();

    const phaseId = phase[0].id;
    const taskIdMap: Record<number, string> = {};

    for (let taskIdx = 0; taskIdx < phaseData.tasks.length; taskIdx++) {
      const taskData = phaseData.tasks[taskIdx];

      const task = await db.insert(tasks).values({
        id: generateId(),
        phaseId,
        planId,
        order: taskIdx + 1,
        title: taskData.title,
        description: taskData.description,
        canRunInParallel: taskData.canRunInParallel,
        dependsOn: [], // will update after all tasks created
        status: 'pending',
        attempts: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();

      taskIdMap[taskIdx] = task[0].id;
    }

    // Update task dependencies with actual IDs
    for (let taskIdx = 0; taskIdx < phaseData.tasks.length; taskIdx++) {
      const taskData = phaseData.tasks[taskIdx];
      if (taskData.dependsOn.length > 0) {
        const dependencyIds = taskData.dependsOn.map((idx: number) => taskIdMap[idx]);
        await db.update(tasks)
          .set({ dependsOn: dependencyIds })
          .where(eq(tasks.id, taskIdMap[taskIdx]));
      }
    }
  }

  // Record generation in iterations
  await db.insert(planIterations).values({
    id: generateId(),
    planId,
    iterationType: 'generation',
    prompt,
    changes: planStructure,
    changedBy: 'claude',
    createdAt: new Date(),
  });

  return planId;
}
```

## Plan Review/Refinement

```typescript
// src/lib/plans/reviewer.ts

export async function reviewPlan(
  planId: string,
  reviewType: 'refine_descriptions' | 'add_missing' | 'optimize_order' | 'break_down',
  scope: 'all' | 'phase' | 'task' = 'all',
  targetId?: string
): Promise<ReviewSuggestions> {
  const plan = await loadPlanWithPhasesAndTasks(planId);

  let contextPrompt = '';

  switch (reviewType) {
    case 'refine_descriptions':
      contextPrompt = `Review the task descriptions and make them clearer and more specific. Each task should have enough detail for Claude to execute without ambiguity.`;
      break;

    case 'add_missing':
      contextPrompt = `Analyze the plan and identify any missing tasks. Consider: error handling, testing, documentation, edge cases, cleanup tasks.`;
      break;

    case 'optimize_order':
      contextPrompt = `Review the order of phases and tasks. Suggest reorderings that would be more logical or efficient. Consider dependencies and what should come first.`;
      break;

    case 'break_down':
      contextPrompt = `Identify tasks that are too complex and should be broken down into smaller, more manageable tasks.`;
      break;
  }

  const prompt = `
You are reviewing an implementation plan. ${contextPrompt}

Current Plan:
${JSON.stringify(plan, null, 2)}

Provide suggestions as JSON array:
[
  {
    "type": "add_task" | "modify_task" | "reorder" | "add_phase" | "break_down_task",
    "target": "description of what to change",
    "reasoning": "why this change is beneficial",
    "before": { ... },  // current state (if modifying)
    "after": { ... }    // proposed change
  }
]
`;

  const session = await createClaudeSession({
    repositoryPath: plan.repository.path,
    prompt,
  });

  const response = await waitForSessionResponse(session.id);
  const suggestions = JSON.parse(response);

  // Save iteration
  const iteration = await db.insert(planIterations).values({
    id: generateId(),
    planId,
    iterationType: 'review',
    prompt,
    changes: { reviewType, suggestions },
    changedBy: 'claude',
    createdAt: new Date(),
  }).returning();

  return {
    iterationId: iteration[0].id,
    suggestions,
  };
}

export async function applySuggestions(
  planId: string,
  iterationId: string,
  suggestionIndices: number[]
): Promise<void> {
  const iteration = await db.query.planIterations.findFirst({
    where: eq(planIterations.id, iterationId)
  });

  const suggestions = iteration.changes.suggestions;

  for (const idx of suggestionIndices) {
    const suggestion = suggestions[idx];

    switch (suggestion.type) {
      case 'add_task':
        await db.insert(tasks).values({
          ...suggestion.after,
          id: generateId(),
          planId,
          status: 'pending',
          attempts: 0,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        break;

      case 'modify_task':
        await db.update(tasks)
          .set(suggestion.after)
          .where(eq(tasks.id, suggestion.target));
        break;

      case 'reorder':
        // Update order fields for affected tasks/phases
        for (const update of suggestion.after.updates) {
          await db.update(tasks)
            .set({ order: update.newOrder })
            .where(eq(tasks.id, update.taskId));
        }
        break;

      case 'add_phase':
        await db.insert(phases).values({
          ...suggestion.after,
          id: generateId(),
          planId,
          status: 'pending',
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        break;

      case 'break_down_task':
        // Replace one task with multiple smaller tasks
        const originalTask = suggestion.before;
        const newTasks = suggestion.after.tasks;

        // Mark original as replaced/deleted
        await db.delete(tasks).where(eq(tasks.id, originalTask.id));

        // Insert new tasks
        for (const newTask of newTasks) {
          await db.insert(tasks).values({
            ...newTask,
            id: generateId(),
            planId,
            phaseId: originalTask.phaseId,
            status: 'pending',
            attempts: 0,
            createdAt: new Date(),
            updatedAt: new Date(),
          });
        }
        break;
    }
  }

  // Update plan timestamp
  await db.update(plans)
    .set({ updatedAt: new Date() })
    .where(eq(plans.id, planId));
}
```

## UI Components

### Plan List View

```typescript
// src/features/plans/components/PlanList.tsx

export function PlanList({ repositoryId }: { repositoryId: string }) {
  const { data: plans } = usePlans(repositoryId);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">Plans</h2>
        <div className="flex gap-2">
          <Button onClick={() => openGenerateDialog()}>
            Generate with Claude
          </Button>
          <Button variant="outline" onClick={() => openCreateDialog()}>
            Create Manually
          </Button>
        </div>
      </div>

      <div className="grid gap-4">
        {plans?.map(plan => (
          <PlanCard key={plan.id} plan={plan} />
        ))}
      </div>
    </div>
  );
}

function PlanCard({ plan }: { plan: Plan }) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-start justify-between">
          <div>
            <CardTitle>{plan.title}</CardTitle>
            <CardDescription>{plan.description}</CardDescription>
          </div>
          <PlanStatusBadge status={plan.status} />
        </div>
      </CardHeader>

      <CardContent>
        <div className="flex items-center gap-6 text-sm text-muted-foreground">
          <span>{plan.totalPhases} phases</span>
          <span>{plan.totalTasks} tasks</span>
          <span>{plan.completedTasks}/{plan.totalTasks} complete</span>
        </div>

        {plan.status === 'running' && (
          <Progress
            value={(plan.completedTasks / plan.totalTasks) * 100}
            className="mt-4"
          />
        )}
      </CardContent>

      <CardFooter className="flex justify-between">
        <div className="text-xs text-muted-foreground">
          Created {formatDistanceToNow(plan.createdAt)} ago
        </div>

        <div className="flex gap-2">
          {plan.status === 'draft' && (
            <>
              <Button size="sm" variant="outline" onClick={() => reviewPlan(plan.id)}>
                Review with Claude
              </Button>
              <Button size="sm" onClick={() => openPlanEditor(plan.id)}>
                Edit
              </Button>
            </>
          )}

          {plan.status === 'ready' && (
            <Button size="sm" onClick={() => executePlan(plan.id)}>
              Execute Plan
            </Button>
          )}

          {plan.status === 'running' && (
            <Button size="sm" variant="outline" onClick={() => pausePlan(plan.id)}>
              Pause
            </Button>
          )}

          {plan.status === 'paused' && (
            <Button size="sm" onClick={() => resumePlan(plan.id)}>
              Resume
            </Button>
          )}

          {(plan.status === 'completed' || plan.status === 'failed') && (
            <Button size="sm" variant="outline" onClick={() => viewPlanDetails(plan.id)}>
              View Details
            </Button>
          )}
        </div>
      </CardFooter>
    </Card>
  );
}
```

### Plan Execution View

```typescript
// src/features/plans/components/PlanExecutionView.tsx

export function PlanExecutionView({ planId }: { planId: string }) {
  const { data: plan } = usePlan(planId);
  const { data: phases } = usePlanPhases(planId);
  const { data: currentTask } = useCurrentTask(planId);

  if (!plan || !phases) return <LoadingSpinner />;

  return (
    <div className="grid lg:grid-cols-3 gap-6">
      {/* Phase/Task Progress - Left Sidebar */}
      <div className="lg:col-span-1">
        <Card>
          <CardHeader>
            <CardTitle>Progress</CardTitle>
            <CardDescription>
              {plan.completedTasks} / {plan.totalTasks} tasks complete
            </CardDescription>
          </CardHeader>

          <CardContent className="space-y-4">
            {phases.map(phase => (
              <PhaseProgressItem key={phase.id} phase={phase} />
            ))}
          </CardContent>
        </Card>
      </div>

      {/* Current Task Details - Main Area */}
      <div className="lg:col-span-2">
        {currentTask && (
          <Card>
            <CardHeader>
              <div className="flex items-start justify-between">
                <div>
                  <CardTitle>{currentTask.title}</CardTitle>
                  <CardDescription>
                    Phase {currentTask.phase.order}: {currentTask.phase.title}
                  </CardDescription>
                </div>
                <TaskStatusBadge status={currentTask.status} />
              </div>
            </CardHeader>

            <CardContent className="space-y-6">
              {/* Task Description */}
              <div>
                <h4 className="text-sm font-medium mb-2">Task Description</h4>
                <p className="text-sm text-muted-foreground whitespace-pre-wrap">
                  {currentTask.description}
                </p>
              </div>

              {/* Claude Output */}
              {currentTask.status === 'running' && (
                <div>
                  <h4 className="text-sm font-medium mb-2">Claude Output</h4>
                  <ClaudeOutputStream sessionId={currentTask.sessionId} />
                </div>
              )}

              {/* QA Results */}
              {currentTask.lastQaResults && (
                <div>
                  <h4 className="text-sm font-medium mb-2">QA Results</h4>
                  <QAResultsList results={currentTask.lastQaResults} />
                </div>
              )}

              {/* Error Display */}
              {currentTask.status === 'failed' && currentTask.lastError && (
                <Alert variant="destructive">
                  <AlertTitle>Task Failed</AlertTitle>
                  <AlertDescription className="whitespace-pre-wrap">
                    {currentTask.lastError}
                  </AlertDescription>
                </Alert>
              )}
            </CardContent>

            <CardFooter className="flex justify-between">
              <div className="text-sm text-muted-foreground">
                Attempt {currentTask.attempts} / 3
              </div>

              <div className="flex gap-2">
                {currentTask.status === 'failed' && (
                  <>
                    <Button size="sm" variant="outline" onClick={() => retryTask(currentTask.id)}>
                      Retry
                    </Button>
                    <Button size="sm" variant="outline" onClick={() => editAndRetry(currentTask.id)}>
                      Edit & Retry
                    </Button>
                    <Button size="sm" variant="outline" onClick={() => skipTask(currentTask.id)}>
                      Skip
                    </Button>
                  </>
                )}
              </div>
            </CardFooter>
          </Card>
        )}

        {/* Pause State */}
        {plan.status === 'paused' && !currentTask && (
          <Card>
            <CardHeader>
              <CardTitle>Plan Paused</CardTitle>
              <CardDescription>Review progress and continue when ready</CardDescription>
            </CardHeader>

            <CardContent>
              <div className="space-y-4">
                <div>
                  <h4 className="text-sm font-medium mb-2">Completed</h4>
                  <ul className="text-sm text-muted-foreground space-y-1">
                    {/* List completed phases/tasks */}
                  </ul>
                </div>

                <div>
                  <h4 className="text-sm font-medium mb-2">Next Up</h4>
                  <p className="text-sm text-muted-foreground">
                    {/* Show next phase/task */}
                  </p>
                </div>
              </div>
            </CardContent>

            <CardFooter className="flex justify-between">
              <Button variant="outline" onClick={() => viewChanges(planId)}>
                Review Changes
              </Button>
              <Button onClick={() => resumePlan(planId)}>
                Continue Execution
              </Button>
            </CardFooter>
          </Card>
        )}
      </div>
    </div>
  );
}
```

## Implementation Phases

### Phase 1: Core Data Models (Week 1)
- [ ] Create database schema (plans, phases, tasks, plan_iterations)
- [ ] Add migrations
- [ ] Create Drizzle queries and relations
- [ ] Basic CRUD API endpoints

### Phase 2: Plan Generation (Week 2)
- [ ] Claude integration for plan generation
- [ ] Parse feature description → structured plan
- [ ] Save generated plans to database
- [ ] UI: generation dialog and form

### Phase 3: Plan Editor (Week 2-3)
- [ ] UI for viewing plan structure
- [ ] Edit phases (add, remove, reorder)
- [ ] Edit tasks (add, remove, reorder, edit descriptions)
- [ ] Set execution modes and pause points
- [ ] Mark plan as "ready"

### Phase 4: Execution Engine (Week 3-4)
- [ ] Core executor class
- [ ] Sequential task execution
- [ ] Parallel task execution with dependency resolution
- [ ] Manual approval mode
- [ ] Pause/resume logic
- [ ] Retry logic with QA gates
- [ ] Auto-commit per task

### Phase 5: Plan Review/Iteration (Week 4)
- [ ] Claude review integration
- [ ] Suggestion generation
- [ ] Apply suggestions to plan
- [ ] Iteration history

### Phase 6: Execution UI (Week 5)
- [ ] Real-time execution view
- [ ] Phase/task progress visualization
- [ ] Claude output streaming
- [ ] QA results display
- [ ] Pause/resume/cancel controls
- [ ] Manual intervention for failed tasks

### Phase 7: Polish & Testing (Week 6)
- [ ] Error handling edge cases
- [ ] Mobile responsive design
- [ ] Loading states and transitions
- [ ] E2E tests for full flow
- [ ] Performance optimization
- [ ] Documentation

## Acceptance Criteria

- [ ] Can generate plan from feature description with Claude
- [ ] Can create plan manually via UI
- [ ] Can edit phases and tasks before execution
- [ ] Can configure execution modes per phase
- [ ] Can execute plans with sequential/parallel/manual modes
- [ ] Context cleared between tasks (fresh Claude session)
- [ ] QA gates run after each task
- [ ] Failed tasks retry up to 3 times
- [ ] Successful tasks auto-commit
- [ ] Can pause execution at any time
- [ ] Can pause automatically after phases (if configured)
- [ ] Can resume from paused state
- [ ] Can manually fix failed tasks and continue
- [ ] Claude can review and suggest plan improvements
- [ ] Track progress at plan/phase/task levels
- [ ] Real-time UI updates during execution
- [ ] Mobile-friendly UI

## Future Enhancements

- Plan templates library (common patterns like "Add CRUD feature", "Add auth", etc.)
- Visual plan editor with drag-drop
- Plan branching (conditional execution paths)
- Plan scheduling (execute at specific time)
- Plan sharing/import/export
- Analytics (avg task duration, failure rates, etc.)
- Cost estimation (predict time/Claude API cost before execution)
- Rollback support (undo plan execution)
- Multi-repo plans (coordinate changes across repos)
- AI-powered plan optimization based on historical data
